<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Max Deadroom — deadroom.net</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,200;0,300;1,200&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :root { --bg: #060608; --fg: #d8d4cc; --cyan: #00e8cc; --mono: 'IBM Plex Mono', monospace; }
    html, body { width: 100%; height: 100%; background: var(--bg); overflow: hidden; font-family: var(--mono); cursor: crosshair; }
    canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: block; }
    nav { position: fixed; top: 0; left: 0; right: 0; z-index: 100; display: flex; justify-content: space-between; align-items: center; padding: 1.8rem 2.5rem; pointer-events: none; }
    .nav-left { pointer-events: all; }
    .site-name { font-size: 0.65rem; letter-spacing: 0.22em; text-transform: uppercase; color: var(--fg); opacity: 0.5; text-decoration: none; transition: opacity 0.3s; }
    .site-name:hover { opacity: 1; }
    .nav-right { display: flex; gap: 2.5rem; pointer-events: all; }
    .nav-right a { font-size: 0.58rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--fg); opacity: 0.3; text-decoration: none; transition: opacity 0.3s; }
    .nav-right a:hover { opacity: 1; }
    #center-ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; text-align: center; transition: opacity 0.8s ease; }
    #center-ui.hidden { opacity: 0; pointer-events: none; }
    .main-title { font-size: clamp(0.9rem, 2vw, 1.1rem); font-weight: 200; font-style: italic; letter-spacing: 0.35em; color: var(--fg); opacity: 0.9; margin-bottom: 0.5rem; text-transform: lowercase; }
    .tagline { font-size: 0.52rem; letter-spacing: 0.25em; text-transform: uppercase; color: var(--fg); opacity: 0.3; margin-bottom: 3rem; }
    #activate-btn { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.22em; text-transform: uppercase; color: var(--bg); background: var(--cyan); border: none; padding: 0.7rem 1.8rem; cursor: pointer; transition: background 0.2s, transform 0.1s; outline: none; }
    #activate-btn:hover { background: #fff; transform: scale(1.03); }
    #activate-btn:active { transform: scale(0.98); }
    #status { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%); z-index: 100; font-size: 0.52rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--fg); opacity: 0; transition: opacity 0.5s; }
    #status.visible { opacity: 0.25; }
    #deny-msg { position: fixed; bottom: 3rem; left: 50%; transform: translateX(-50%); z-index: 100; font-size: 0.55rem; letter-spacing: 0.12em; color: #ff2244; opacity: 0; transition: opacity 0.5s; white-space: nowrap; }
    #deny-msg.visible { opacity: 0.7; }
  </style>
</head>
<body>

<nav>
  <div class="nav-left"><a href="/" class="site-name">deadroom.net</a></div>
  <div class="nav-right">
    <a href="/work">work</a>
    <a href="/music">music</a>
    <a href="/about">about</a>
    <a href="mailto:max@deadroom.net">contact</a>
  </div>
</nav>

<div id="center-ui">
  <div class="main-title">max deadroom</div>
  <div class="tagline">visual onomatopoeia &nbsp;·&nbsp; sound on screen</div>
  <button id="activate-btn">activate microphone</button>
</div>
<div id="status">listening</div>
<div id="deny-msg">microphone access denied — running in autonomous mode</div>

<script>
// ── Web Audio API ─────────────────────────────────────
let audioCtx = null, analyser = null, dataArray = null;

const btn      = document.getElementById('activate-btn');
const centerUI = document.getElementById('center-ui');
const statusEl = document.getElementById('status');
const denyMsg  = document.getElementById('deny-msg');

btn.addEventListener('click', async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.88;
    audioCtx.createMediaStreamSource(stream).connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    window._micReady = true;
    centerUI.classList.add('hidden');
    statusEl.classList.add('visible');
  } catch(e) {
    window._micDenied = true;
    centerUI.classList.add('hidden');
    denyMsg.classList.add('visible');
    setTimeout(() => denyMsg.classList.remove('visible'), 4000);
  }
});

function getRawSpectrum() {
  if (!analyser || !dataArray) return null;
  analyser.getByteFrequencyData(dataArray);
  return dataArray;
}

// ── p5 sketch ─────────────────────────────────────────
new p5(function(s) {

  const NUM_BANDS = 128;
  const NUM_RINGS = 4;

  let activated  = false;
  let micAllowed = false;
  let t = 0, autoPhase = 0;

  // Amplitude envelope: fast attack, slow release
  let peakAmp  = 0;
  let bands    = new Array(NUM_BANDS).fill(0);
  let bandPeak = new Array(NUM_BANDS).fill(0);

  // Gated hue oscillator
  // Oscillator runs continuously but only advances when a peak crosses
  // the gate threshold. Between transients hue locks at its current value.
  const HUE_GATE_THRESH = 0.18; // amplitude threshold to open gate
  const HUE_SPEED       = 0.28; // degrees per frame at full gate open
  let huePhase   = 168;         // starts at cyan
  let gateLevel  = 0;           // smoothed gate signal 0–1
  let displayHue = 168;         // hue used for drawing, interpolates toward huePhase

  let rings     = [];
  let fragments = [];

  // ── Setup ─────────────────────────────────────────
  s.setup = function() {
    let cnv = s.createCanvas(s.windowWidth, s.windowHeight);
    cnv.position(0, 0);
    s.colorMode(s.HSB, 360, 100, 100, 100);
    s.angleMode(s.RADIANS);
    s.noFill();

    for (let i = 0; i < NUM_RINGS; i++) {
      rings.push({
        baseRadius: 85 + i * 62,
        phase:      (i / NUM_RINGS) * s.TWO_PI,
        rotSpeed:   (0.0012 + i * 0.0007) * (i % 2 === 0 ? 1 : -1),
        thickness:  2.8 + i * 0.9,
        sat:        62 + i * 7,
        segments:   256
      });
    }
  };

  // ── Draw ──────────────────────────────────────────
  s.draw = function() {

    // Mic handshake
    if (window._micReady  && !activated) { activated = true; micAllowed = true;  window._micReady  = false; }
    if (window._micDenied && !activated) { activated = true; micAllowed = false; window._micDenied = false; }

    t = s.millis() * 0.001;
    autoPhase += 0.006;

    // ── Signal processing ────────────────────────────
    let instAmp = 0;
    if (micAllowed) {
      let raw = getRawSpectrum();
      if (raw) {
        let binSize = Math.floor(raw.length / NUM_BANDS);
        for (let i = 0; i < NUM_BANDS; i++) {
          let sum = 0;
          for (let j = 0; j < binSize; j++) sum += raw[i * binSize + j];
          let v = (sum / binSize) / 255;
          instAmp += v;
          bandPeak[i] = v > bandPeak[i]
            ? s.lerp(bandPeak[i], v, 0.45)
            : s.lerp(bandPeak[i], v, 0.03);
          bands[i] = bandPeak[i];
        }
        instAmp /= NUM_BANDS;
      }
    } else {
      // Autonomous Perlin noise signal
      instAmp = s.noise(t * 0.3) * 0.28 + 0.04;
      for (let i = 0; i < NUM_BANDS; i++) {
        let v = s.noise(i * 0.08, t * 0.22) * 0.6;
        bandPeak[i] = v > bandPeak[i]
          ? s.lerp(bandPeak[i], v, 0.2)
          : s.lerp(bandPeak[i], v, 0.025);
        bands[i] = bandPeak[i];
      }
    }

    // Global peak-hold amplitude
    peakAmp = instAmp > peakAmp
      ? s.lerp(peakAmp, instAmp, 0.35)
      : s.lerp(peakAmp, instAmp, 0.012);

    // ── Gated hue oscillator ─────────────────────────
    let rawGate = peakAmp > HUE_GATE_THRESH ? 1.0 : 0.0;
    gateLevel = rawGate > gateLevel
      ? s.lerp(gateLevel, rawGate, 0.4)    // fast attack
      : s.lerp(gateLevel, rawGate, 0.04);  // slow release

    huePhase = (huePhase + HUE_SPEED * gateLevel) % 360;

    // Shortest-arc interpolation to prevent 360→0 snap
    let diff = ((huePhase - displayHue + 540) % 360) - 180;
    displayHue = (displayHue + diff * 0.08 + 360) % 360;

    let hue2 = (displayHue + 22) % 360;

    // ── Background ───────────────────────────────────
    s.background(240, 18, 3, 22);

    let cx = s.width  / 2;
    let cy = s.height / 2;

    // ── Waveform rings ────────────────────────────────
    // Each ring is a single continuous closed shape.
    // FFT bands modulate radial displacement — no individual lines.
    let ampMod = peakAmp * (activated ? 85 : 45);

    for (let ri = 0; ri < NUM_RINGS; ri++) {
      let r = rings[ri];
      r.phase += r.rotSpeed;

      let baseR = r.baseRadius + ampMod;

      // Outer ring
      s.beginShape();
      for (let i = 0; i <= r.segments; i++) {
        let pct   = i / r.segments;
        let angle = pct * s.TWO_PI + r.phase;
        let bidx  = Math.floor(pct * NUM_BANDS);
        let bv    = bands[bidx] || 0;

        let disp = activated
          ? bv * (75 + ri * 22)
          : s.noise(i * 0.035, t * 0.16 + ri) * (22 + ri * 7);

        let rx = cx + s.cos(angle) * (baseR + disp);
        let ry = cy + s.sin(angle) * (baseR + disp);

        let alpha = activated
          ? s.constrain(16 + bv * 58 + peakAmp * 30, 8, 85)
          : s.constrain(7 + ri * 3, 4, 22);

        s.stroke(displayHue, r.sat, 88, alpha);
        s.strokeWeight(r.thickness + (activated ? bv * 2.2 : 0));
        s.vertex(rx, ry);
      }
      s.endShape(s.CLOSE);

      // Inner counter-rotating mirror ring
      let innerBase = r.baseRadius * 0.5 + ampMod * 0.35;
      s.beginShape();
      for (let i = 0; i <= r.segments; i++) {
        let pct   = i / r.segments;
        let angle = pct * s.TWO_PI - r.phase * 0.65;
        let bidx  = Math.floor(pct * NUM_BANDS);
        let bv    = bands[bidx] || 0;

        let disp = activated
          ? bv * (38 + ri * 10)
          : s.noise(i * 0.045, t * 0.13 + ri + 8) * (12 + ri * 4);

        let rx = cx + s.cos(angle) * (innerBase + disp);
        let ry = cy + s.sin(angle) * (innerBase + disp);

        let alpha = activated
          ? s.constrain(9 + bv * 36 + peakAmp * 18, 4, 55)
          : s.constrain(4 + ri * 2, 2, 14);

        s.stroke(hue2, r.sat - 14, 92, alpha);
        s.strokeWeight((r.thickness * 0.52) + (activated ? bv * 1.0 : 0));
        s.vertex(rx, ry);
      }
      s.endShape(s.CLOSE);
    }

    // ── Fragments ─────────────────────────────────────
    // Slow, long-lived shards. Fade in gently, decay slowly.
    if (fragments.length < 100) {
      let prob = activated
        ? (peakAmp > 0.2 ? peakAmp * 0.35 : 0)
        : 0.015;
      if (s.random() < prob) {
        let angle  = s.random(s.TWO_PI);
        let midR   = (rings[0].baseRadius + rings[NUM_RINGS-1].baseRadius) * 0.5;
        let spawnR = midR + s.random(-70, 70);
        let spd    = activated ? s.random(0.35, 1.2) : s.random(0.08, 0.35);
        let fragHue = (displayHue + s.random(-18, 18) + 360) % 360;
        fragments.push({
          x: cx + s.cos(angle) * spawnR,
          y: cy + s.sin(angle) * spawnR,
          vx: s.cos(angle + s.random(-0.5, 0.5)) * spd * 0.25,
          vy: s.sin(angle + s.random(-0.5, 0.5)) * spd * 0.25,
          sz: s.random(5, 15) * (1 + peakAmp * 1.2),
          ang: s.random(s.TWO_PI),
          spin: s.random(-0.018, 0.018),
          life: 0.0,
          growing: true,
          decay: s.random(0.004, 0.011),
          hue: fragHue,
          sat: 65 + s.random(22)
        });
      }
    }

    for (let i = fragments.length - 1; i >= 0; i--) {
      let f = fragments[i];
      f.x += f.vx;
      f.y += f.vy;
      f.ang += f.spin;

      if (f.growing) {
        f.life = Math.min(f.life + 0.04, 1.0);
        if (f.life >= 1.0) f.growing = false;
      } else {
        f.life -= f.decay;
      }
      if (f.life <= 0) { fragments.splice(i, 1); continue; }

      s.push();
      s.translate(f.x, f.y);
      s.rotate(f.ang);
      s.stroke(f.hue, f.sat, 88, f.life * 55);
      s.strokeWeight(2.0);
      s.noFill();
      s.beginShape();
      s.vertex(0, -f.sz);
      s.vertex(f.sz * 0.65, -f.sz * 0.15);
      s.vertex(f.sz * 0.45, f.sz * 0.72);
      s.vertex(-f.sz * 0.35, f.sz * 0.48);
      s.vertex(-f.sz * 0.52, -f.sz * 0.42);
      s.endShape(s.CLOSE);
      s.pop();
    }

    // ── Central void ──────────────────────────────────
    let voidR = 26 + peakAmp * 38;
    for (let i = 3; i >= 0; i--) {
      let rr = voidR + i * 9;
      let a  = activated
        ? s.constrain(2.5 + peakAmp * 16 - i * 2, 0, 25)
        : Math.max(0, 1.2 - i * 0.3);
      s.stroke(220, 14, 16, a);
      s.strokeWeight(1.8);
      s.ellipse(cx, cy, rr * 2, rr * 2);
    }

    if (activated) {
      let dotR = 2 + peakAmp * 7;
      s.fill(displayHue, 50, 88, 30 + peakAmp * 40);
      s.noStroke();
      s.ellipse(cx, cy, dotR * 2, dotR * 2);
      s.noFill();
    }
  };

  s.windowResized = function() {
    s.resizeCanvas(s.windowWidth, s.windowHeight);
  };

});
</script>
</body>
</html>
